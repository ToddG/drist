#!/bin/sh
#vim:shiftwidth=4;

##
# drist --
# A tool to configure and synchronize configurations to, and/or
# run scrips on remote host(s) via scp(1) and ssh(1).
#
# SYNOPSIS
# drist [-p] [-d] [-e [sudo|doas]] [-S script] [-f files-directory] [-F file-to-copy] destination [...]
#

# ---[ GLOBALS ]--------------------------------------------------
PRIVILEGES=0                  # Run with escillated privileges
PRIVILEGES_BIN=doas           # binary to run priviliged command.
EXEC="exec sh -c "            # posix compliant shell.
SSHONCE=0                     # set up a socket for persistent connection.
TRUNCATE=0                    # Remove the domain name from the hostname.
USE_FILE="script"             # defult script file to upload if no optional switches.
USE_DIR="files"               # default directory to upload if no optional switches.

# ---[ HELPERS ]--------------------------------------------------
##
# usage --
# @brief displays usage information.
usage() {
    echo "$0 v2.04"
    echo "$0 [-p] [-d] [-e [sudo|doas]] [-S script-to-run] [-f files-to-copy-directory] [-F single-file-to-copy] destination [...]"
    exit 0
}

##
# copy_files --
# @brief Copy files from a local directory to a remote server.
#
# Parameters:
#   $1 - source directory (e.g. /path/files-server.local)
#   $2 - remote server name (e.g. server)
#   $3 - remote tempdir target (e.g. ~/.drist_files_XXXXXXXXXXXXXXX)
copy_files() {
    src_dir=$1
    remote_server=$2
    remote_tmp=$3

    if [ -d "${src_dir}" ]; then
        # create list file
        LIST=$(mktemp /tmp/drist-sync.XXXXXXXXXX)
        # Get the current working directory.
        CWD=$(pwd)
        if [ -f "$LIST" ]; then
            # -l = keep symlink / -D = special device
            find "${src_dir}" -type f -or -type l | sed "s#^${src_dir}/##" > "${LIST}"
            cd $(dirname -- ${src_dir})          # `dirname path/directory` will return 'path'.

            # basename of source dir (e.g. files-server.local from /path/files-server.local)
            SRC_BASE=$(basename -- "${src_dir}")

            scp $SSH_PARAMS -r -q "${SRC_BASE}/" "${remote_server}":"${remote_tmp}"
            ssh $SSH_PARAMS "${remote_server}" 'owd=$(pwd); cd '"${remote_tmp}"'/'"$SRC_BASE"' ; tar cf - . | ( tar xf - -C "$owd" )'
            cd ${CWD}
            rm "$LIST"
        fi
    fi
}

##
# copy_single_file --
# @brief Copy a single file from a local directory to a remote server.
#
# Parameters:
#   $1 - source file (e.g. /path/upload.file)
#   $2 - remote server name (e.g. server)
#   $3 - remote tempdir target (e.g. ~/.drist_files_XXXXXXXXXXXXXXX)
copy_single_file() {
    src_file=$1
    remote_server=$2
    remote_tmp=$3

    if [ -f "${1}" ]; then
        # create list file
        LIST=$(mktemp /tmp/drist-sync.XXXXXXXXXX)
        # Get the current working directory.
        CWD=$(pwd)                      # Get the current working directory.
        if [ -f "$LIST" ]; then
            # -l = keep symlink / -D = special device
            find "${src_file}" -type f -or -type l | sed "s#^${src_file}/##" > "${LIST}"

            cd $(dirname ${1})          # `dirname path/directory` will return 'path'.
            FILE_NAME=$(basename ${1})
            scp $SSH_PARAMS -q "./${FILE_NAME}" "${2}":"${3}"
            ssh $SSH_PARAMS "${2}" "cd $3/ ; tar cf - . | ( tar xf - -C ../ )"
            cd ${CWD}                   # Change back to current working directory.
            rm "$LIST"
        fi
    fi
}

##
# remote_script --
# @brief Executes script on remote host.
#
# Parameters:
#   $1 - script file (e.g. /path/script)
#   $2 - remote server name (e.g. server)
#   $3 - remote tempdir target (e.g. ~/.drist_files_XXXXXXXXXXXXXXX)
remote_script() {
    src_dir=$1
    remote_server=$2
    remote_tmp=$3

    if [ -f "${1}" ]; then
        FILE=$(basename ${USE_FILE})
        ssh $SSH_PARAMS "${2}" "cd ${3} && \
            cat - > ${3}/${FILE} && \
            chmod u+x ${3}/${FILE} && \
            ${EXEC} ${3}/${FILE}" < "$1"
    fi
}

##
# create_temp --
# @brief Creates temporary directory on remote host.
#
# Parameters:
#   $1 - remote server name (e.g. server)
create_temp() {
    remote_server=$1

    TEMPDIR=$(ssh $SSH_PARAMS "${remote_server}" "mktemp -d ~/.drist_files_XXXXXXXXXXXXXXX")
    if [ "$TEMPDIR" = "" ]; then
        echo "mktemp error, aborting"
        exit 1
    fi
}

##
# delete_temp --
# @brief Deletes temporary directory on remote host.
#
# Parameters:
#   $1 - remote server name (e.g. server)
#   $2 - remote tempdir target (e.g. ~/.drist_files_XXXXXXXXXXXXXXX)
delete_temp() {
    remote_server=$1
    remote_tmp=$2

    # The following is a debug print.
    if echo "${2}" | grep drist_files_ >/dev/null ; then
        ssh $SSH_PARAMS "$1" "rm -fr ${2}"
    else
        echo "Problem, TEMPDIR was reset during execution, current value is = $2"
        exit 2
    fi
}


# ---[ ARGUMENT PARSER ]------------------------------------------
# (custom getopt() like argument parser)

# check to see if we have enough arguments.
if [ $# -lt 1 ]; then echo "Not enough arguments."; fi

# flag to set when done processing arguments.
done_options=

##
# @brief check to see if there are more arguments to parse.
#
# @return 1 if done 0 if more args.
more_options() {
    test $done_options && return 1
    [ $# -eq 0 ] && return 1
    case "$1" in
        --) return 1 ;;   # stop options
        -*) return 0 ;;
        *) return 1 ;;
    esac
}

# parse arguments.
while more_options "$1"
do
    case "$1" in
        --)
            done_options=1
            shift
            break
            ;;
        -h*)                                            # Help
            usage
            ;;
        -d)                                             # truncate hostname
            TRUNCATE=1
            ;;
        -p)                                             # persistant ssh
            SSHONCE=1
            ;;
        -S)                                             # script file to run
            [ $# -gt 1 ] || usage "-S requires a script name"
            shift
            USE_FILE="$1"
            ;;
        -f)                                             # directory of files to upload
            [ $# -gt 1 ] || usage "-f requires a directory location"
            shift
            USE_DIR="$1"
            ;;
        -F)                                             # file to upload
            [ $# -gt 1 ] || usage "-F requires a file name"
            shift
            COPY_FILE="$1"
            ;;
        -e*)                                            # elevate premissions.
            if [ $# -gt 1 ] && case "$2" in -*) false;; *) true;; esac; then
                shift
                PRIVILEGES_BIN="${1#-e}"
            fi
            PRIVILEGES=1
            ;;
        -*)
            usage "unknown option $1"
            ;;
    esac
    shift
done

# ---[ RUNTIME ]--------------------------------------------------
# allow to use a privilege escalation program
if [ "$PRIVILEGES" -eq 1 ]; then
    EXEC="$PRIVILEGES_BIN"
fi

# use ControlMaster to make connections persistent
if [ "$SSHONCE" -eq 1 ]; then
    SSH_PARAMS=-o"ControlMaster=auto"" "-o"ControlPath=/tmp/drist_ssh_%h_%p_%r.sock"" "-o"ControlPersist=1m"
fi

# start looping over server list
if [ -f "$1" ]; then
    SERVER_LIST="$(tr '\n' ' ' < $1)"
else
    SERVER_LIST="$@"
fi

if [ "${SERVER_LIST}" = "" ]; then
    echo "No server specified"
    exit 1
fi

for remote_server in ${SERVER_LIST}
do

  # check if host exists
  HOSTNAME=$(ssh $SSH_PARAMS "${remote_server}" "uname -n")
  if [ "$?" -ne 0 ]; then
      echo "Error while ssh ${remote_server}"
      exit 2
  fi

  if [ "$TRUNCATE" -eq 1 ]; then
      HOSTNAME="${HOSTNAME%%.*}"
  fi

  create_temp "${remote_server}"
  copy_files "${USE_DIR}" "${remote_server}" "$TEMPDIR"
  copy_files "${USE_DIR}-${HOSTNAME}" "${remote_server}" "$TEMPDIR"
  copy_single_file "${COPY_FILE}" "${remote_server}" "$TEMPDIR"
  copy_single_file "${COPY_FILE}-${HOSTNAME}" "${remote_server}" "$TEMPDIR"
  remote_script "${USE_FILE}" "${remote_server}" "$TEMPDIR"
  remote_script "${USE_FILE}-${HOSTNAME}" "${remote_server}" "$TEMPDIR"
  delete_temp "${remote_server}" "$TEMPDIR"

  # close socket if persistance is actived
  if [ "$SSHONCE" -eq 1 ]; then
      ssh $SSH_PARAMS -O exit -N "$1"
  fi

  unset TEMPDIR HOSTNAME
done
